#include <iostream>
#include <string>
#include <windows.h>


// Алгоритм быстрой сортировки
// 
// int* arr         - исходный массив
// [L, R]           - интервал массива, который будем просматривать для выполнения сортировки
// int L            - индекс интервала слева
// int R            - индекс интервала справа
//
// Пример:
// Дан массив { 3, 43, 38, 29, 18, 72, 57, 61, 2, 33 }
// Опорный элемент p[4] = 18
// Значения инднксов i и j
//  3, 43, 38, 29, 18, 72, 57, 61, 2, 33
//  |                                  |
//  i                                  j
// 
//  этап 1
// ищим элемент слева направо больше или равным 18 - это 43
// ищим элемент справа налево меньше или равным 18 - это 2
//  3, 43, 38, 29, 18, 72, 57, 61, 2, 33
//     |                           |
//     i                           j
// меняем местами элементы
//  3, 2, 38, 29, 18, 72, 57, 61, 43, 33
//     |                           |
//     i                           j
// увеличиваем индекс i=i+1 и уменьшаем индекс j=j-1
//  3, 2, 38, 29, 18, 72, 57, 61, 43, 33
//        |                    |
//        i                    j
// 
//  этап 2
// ищим элемент слева направо больше или равным 18 - это 38
// ищим элемент справа налево меньше или равным 18 - это 18
//  3, 2, 38, 29, 18, 72, 57, 61, 43, 33
//        |        |
//        i        j
// меняем местами элементы
//  3, 2, 18, 29, 38, 72, 57, 61, 43, 33
//        |        |
//        i        j
// увеличиваем индекс i=i+1 и уменьшаем индекс j=j-1
//  3, 2, 18, 29, 38, 72, 57, 61, 43, 33
//            ||
//           i, j
//
//  этап 3
// ищим элемент слева направо больше или равным 18 - это 29
// ищим элемент справа налево меньше или равным 18 - отсутствуют. После проверки текущего элемента и уменьшения j<i
//  3, 2, 18, 29, 38, 72, 57, 61, 43, 33
//            ||
//           i, j




void quick_sort(int* arr, int L, int R) {
    // Выход из рекурсии
    if (L > R) return;

    int p = arr[(L + R) / 2];   // опорное значение запоминаем посередине массива
    int i = L;                  // начальное значение индекса при движении по массиву слева направо
    int j = R;                  // начальное значение индекса при движении по массиву справа налево
    while (i <= j) {
        while (arr[i] < p) i++;     // ищим значение массива больше или равно p двигаясь по массиву от левой границы
        while (arr[j] > p) j--;     // ищим значение массива меньше или равно p двигаясь по массиву от правой границы
        //
        if (i <= j) {
            // меняем местами эти значения
            int tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
            // индекс i на шаг увеличиваем
            i++;
            // индекс j на шаг уменьшаем
            j--;
        }
    }
    // После цикла j < i
    // запускаем рекурсивно сортировку по левой части массива
    quick_sort(arr, L, j);
    // запускаем рекурсивно сортировку по правой части массива
    quick_sort(arr, L, j);
}



// Печатаем массив
void print_array(int* arr, int size) {
    for (int i = 0; i < size; i++) {
        std::cout << arr[i] << " ";
    }
}



// ГЛАВНАЯ ПРОГРАММА
int main()
{
    // Установка кодировки консоли Windows
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    // Исходные данные
    int arr1[] = { 3, 43, 38, 29, 18, 72, 57, 61, 2, 33 };
    int arr2[] = { 88, 91, 87, 59, 53, 49, 29, 16, 4, 27, 28, 89, 2, 25, 74 };
    int arr3[] = { 24, 66, 20, 79, 30, 16, 19, 62, 94, 59, 0, 7, 59, 90, 84, 60, 95, 62 };

    // Размеры массивов
    int size1 = sizeof(arr1) / sizeof(arr1[0]);
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int size3 = sizeof(arr3) / sizeof(arr3[0]);

    // Сортировка и вывод результатов
    std::cout << "Исходный массив 1: ";
    print_array(arr1, size1);
    merge_sort(arr1, size1);
    std::cout << std::endl;
    std::cout << "Отсортированный массив 1: ";
    print_array(arr1, size1);
    std::cout << std::endl << std::endl;


    std::cout << "Исходный массив 2: ";
    print_array(arr2, size2);
    merge_sort(arr2, size2);
    std::cout << std::endl;
    std::cout << "Отсортированный массив 2: ";
    print_array(arr2, size2);
    std::cout << std::endl << std::endl;

    std::cout << "Исходный массив 3: ";
    print_array(arr3, size3);
    merge_sort(arr3, size3);
    std::cout << std::endl;
    std::cout << "Отсортированный массив 3: ";
    print_array(arr3, size3);
    std::cout << std::endl << std::endl;

    //std::cout << std::endl;
    //std::cout << "Нажмите любую клавишу для завершения программы." << std::endl;
    //std::cout << std::endl;

    system("pause");

    return EXIT_SUCCESS;
}

/*
pivoting(A, pi):
 left = 0
 right = длина(А)-1
 pivot = A[pi]
 while true
 while A[left] < pivot
 left += 1
 while A[right] > pivot
 right -= 1
 if left >= right
 return left
 swap A[left] A[right]
 left += 1
 right -= 1
Увеличиваем left пока элементы меньше пивота,
уменьшаем right пока элементы больше пивота
Если left и right ещё не встретились, то поменяем
местами эти элементы, увеличим left и уменьшим right,
иначе вернём left как границу пивотирования
*/